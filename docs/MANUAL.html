<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Kraken Manual - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="kraken.css" type="text/css" />
  <link href='http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic' rel='stylesheet' type='text/css'>
</head>
<body>
<div class="pretoc">
  <p class="title">Kraken taxonomic sequence classification system</p>

  <p class="version">Version 0.10.5-beta</p>

  <p>Operating Manual</p>
</div>

<h1>Table of Contents</h1>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#system-requirements">System Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#kraken-databases">Kraken Databases</a></li>
<li><a href="#standard-kraken-database">Standard Kraken Database</a></li>
<li><a href="#classification">Classification</a></li>
<li><a href="#output-format">Output Format</a></li>
<li><a href="#custom-databases">Custom Databases</a></li>
<li><a href="#memory-usage-and-efficiency">Memory Usage and Efficiency</a></li>
<li><a href="#sample-reports">Sample Reports</a></li>
<li><a href="#confidence-scoring">Confidence Scoring</a></li>
<li><a href="#kraken-environment-variables">Kraken Environment Variables</a></li>
<li><a href="#upgrading-databases-to-v0.10">Upgrading Databases to v0.10+</a></li>
</ul>
</div>
<h1 id="introduction"><a href="#introduction">Introduction</a></h1>
<p><a href="http://ccb.jhu.edu/software/kraken/">Kraken</a> is a taxonomic sequence classifier that assigns taxonomic labels to short DNA reads. It does this by examining the <span class="math"><em>k</em></span>-mers within a read and querying a database with those <span class="math"><em>k</em></span>-mers. This database contains a mapping of every <span class="math"><em>k</em></span>-mer in <a href="http://ccb.jhu.edu/software/kraken/">Kraken</a>'s genomic library to the lowest common ancestor (LCA) in a taxonomic tree of all genomes that contain that <span class="math"><em>k</em></span>-mer. The set of LCA taxa that correspond to the <span class="math"><em>k</em></span>-mers in a read are then analyzed to create a single taxonomic label for the read; this label can be any of the nodes in the taxonomic tree. <a href="http://ccb.jhu.edu/software/kraken/">Kraken</a> is designed to be rapid, sensitive, and highly precise. Our tests on various real and simulated data have shown <a href="http://ccb.jhu.edu/software/kraken/">Kraken</a> to have sensitivity slightly lower than Megablast with precision being slightly higher. On a set of simulated 100 bp reads, <a href="http://ccb.jhu.edu/software/kraken/">Kraken</a> processed over 1.3 million reads per minute on a single core in normal operation, and over 4.1 million reads per minute in quick operation.</p>
<p>The latest released version of Kraken will be available at the <a href="http://ccb.jhu.edu/software/kraken/">Kraken website</a>, and the latest updates to the Kraken source code are available at the <a href="https://github.com/DerrickWood/kraken">Kraken GitHub repository</a>.</p>
<p>If you use <a href="http://ccb.jhu.edu/software/kraken/">Kraken</a> in your research, please cite the <a href="http://genomebiology.com/2014/15/3/R46">Kraken paper</a>. Thank you!</p>
<h1 id="system-requirements"><a href="#system-requirements">System Requirements</a></h1>
<p>Note: Users concerned about the disk or memory requirements should read the paragraph about MiniKraken, below.</p>
<ul>
<li><p><strong>Disk space</strong>: Construction of Kraken's standard database will require at least 160 GB of disk space. Customized databases may require more or less space. Disk space used is linearly proportional to the number of distinct <span class="math"><em>k</em></span>-mers; as of Feb. 2015, Kraken's default database contains just under 6 billion (6e9) distinct <span class="math"><em>k</em></span>-mers.</p>
<p>In addition, the disk used to store the database should be locally-attached storage. Storing the database on a network filesystem (NFS) partition can cause Kraken's operation to be very slow, or to be stopped completely. As NFS accesses are much slower than local disk accesses, both preloading and database building will be slowed by use of NFS.</p></li>
<li><p><strong>Memory</strong>: To run efficiently, Kraken requires enough free memory to hold the database in RAM. While this can be accomplished using a ramdisk, Kraken supplies a utility for loading the database into RAM via the OS cache. The default database size is 75 GB (as of Feb. 2015), and so you will need at least that much RAM if you want to build or run with the default database.</p></li>
<li><p><strong>Dependencies</strong>: Kraken currently makes extensive use of Linux utilities such as sed, find, and wget. Many scripts are written using the Bash shell, and the main scripts are written using Perl. Core programs needed to build the database and run the classifier are written in C++, and need to be compiled using g++. Multithreading is handled using OpenMP. Downloads of NCBI data are performed by wget and in some cases, by rsync. Most Linux systems that have any sort of development package installed will have all of the above listed programs and libraries available.</p>
<p>Finally, if you want to build your own database, you will need to install the <a href="http://www.cbcb.umd.edu/software/jellyfish/">Jellyfish</a> <span class="math"><em>k</em></span>-mer counter. Note that Kraken only supports use of Jellyfish version 1. Jellyfish version 2 is not yet compatible with Kraken.</p></li>
<li><p><strong>Network connectivity</strong>: Kraken's standard database build and download commands expect unfettered FTP and rsync access to the NCBI FTP server. If you're working behind a proxy, you may need to set certain environment variables (such as <code>ftp_proxy</code> or <code>RSYNC_PROXY</code>) in order to get these commands to work properly.</p></li>
<li><p><strong>MiniKraken</strong>: To allow users with low-memory computing environments to use Kraken, we supply a reduced standard database that can be downloaded from the Kraken web site. When Kraken is run with a reduced database, we call it MiniKraken.</p>
<p>The database we make available is only 4 GB in size, and should run well on computers with as little as 8 GB of RAM. Disk space required for this database is also only 4 GB.</p></li>
</ul>
<h1 id="installation"><a href="#installation">Installation</a></h1>
<p>To begin using Kraken, you will first need to install it, and then either download or create a database.</p>
<p>Kraken consists of two main scripts (&quot;<code>kraken</code>&quot; and &quot;<code>kraken-build</code>&quot;), along with several programs and smaller scripts. As part of the installation process, all scripts and programs are installed in the same directory. After installation, you can move the main scripts elsewhere, but moving the other scripts and programs requires editing the scripts and changing the &quot;<code>$KRAKEN_DIR</code>&quot; variables.</p>
<p>Once a directory is selected, you need to run the following command in the directory where you extracted the Kraken source:</p>
<pre><code>./install_kraken.sh $KRAKEN_DIR</code></pre>
<p>(Replace &quot;<code>$KRAKEN_DIR</code>&quot; above with the directory where you want to install Kraken's programs/directories.)</p>
<p>The <code>install_kraken.sh</code> script should compile all of Kraken's code and setup your Kraken data directory. Installation is successful if you see the message &quot;<code>Kraken installation complete.</code>&quot;</p>
<p>Once installation is complete, you may want to copy the two main Kraken scripts into a directory found in your <code>PATH</code> variable (e.g., &quot;<code>$HOME/bin</code>&quot;):</p>
<pre><code>cp $KRAKEN_DIR/bin/kraken $HOME/bin
cp $KRAKEN_DIR/bin/kraken-build $HOME/bin</code></pre>
<p>After installation, you're ready to either create or download a database.</p>
<h1 id="kraken-databases"><a href="#kraken-databases">Kraken Databases</a></h1>
<p>A Kraken database is a directory containing at least 4 files:</p>
<ul>
<li><code>database.kdb</code>: Contains the <span class="math"><em>k</em></span>-mer to taxon mappings</li>
<li><code>database.idx</code>: Contains minimizer offset locations in database.kdb</li>
<li><code>taxonomy/nodes.dmp</code>: Taxonomy tree structure + ranks</li>
<li><code>taxonomy/names.dmp</code>: Taxonomy names</li>
</ul>
<p>Other files may be present as part of the database build process.</p>
<p>In interacting with Kraken, you should not have to directly reference any of these files, but rather simply provide the name of the directory in which they are stored. Kraken allows both the use of a standard database as well as custom databases; these are described in the sections <a href="#standard-kraken-database">Standard Kraken Database</a> and <a href="#custom-databases">Custom Databases</a> below, respectively.</p>
<h1 id="standard-kraken-database"><a href="#standard-kraken-database">Standard Kraken Database</a></h1>
<p>To create the standard Kraken database, you can use the following command:</p>
<pre><code>kraken-build --standard --db $DBNAME</code></pre>
<p>(Replace &quot;<code>$DBNAME</code>&quot; above with your preferred database name/location. Please note that the database will use approximately 160 GB of disk space during creation.)</p>
<p>This will download NCBI taxonomic information, as well as the complete genomes in RefSeq for the bacterial, archaeal, and viral domains. After downloading all this data, the build process begins; this is the most time-consuming step. If you have multiple processing cores, you can run this process with multiple threads, e.g.:</p>
<pre><code>kraken-build --standard --threads 16 --db $DBNAME</code></pre>
<p>Using 16 threads on a computer with 122 GB of RAM, the build process took approximately an hour and a half (steps with an asterisk have some multi-threading enabled) in February 2015:</p>
<pre><code> 7m48s  *Step 1 (create set)
   n/a   Step 2 (reduce database, optional and skipped)
53m16s  *Step 3 (sort set)
 1m04s   Step 4 (GI number to sequence ID map)
 0m27s   Step 5 (Sequence ID to taxon map)
29m20s  *Step 6 (set LCA values)
------
91m55s   Total build time</code></pre>
<p>Note that if any step (including the initial downloads) fails, the build process will abort. However, <code>kraken-build</code> will produce checkpoints throughout the installation process, and will restart the build at the last incomplete step if you attempt to run the same command again on a partially-built database.</p>
<p>To create a custom database, or to use a database from another source, see <a href="#custom-databases">Custom Databases</a>.</p>
<p>Notes for users with lower amounts of RAM:</p>
<ol style="list-style-type: decimal">
<li><p>If you encounter problems with Jellyfish not being able to allocate enough memory on your system to run the build process, you can supply a smaller hash size to Jellyfish using <code>kraken-build</code>'s <code>--jellyfish-hash-size</code> switch. Each space in the hash table uses approximately 6.9 bytes, so using &quot;<code>--jellyfish-hash-size 6400M</code>&quot; will use a hash table size of 6.4 billion spaces and require 44.3 GB of RAM.</p></li>
<li><p>Kraken's build process will normally attempt to minimize disk writing by allocating large blocks of RAM and operating within them until data needs to be written to disk. However, this extra RAM usage may exceed your capacity. In such cases, you may want to use <code>kraken-build</code>'s <code>--work-on-disk</code> switch. This will minimize the amount of RAM usage and cause Kraken's build programs to perform most operations off of disk files. This switch can also be useful for people building on a ramdisk or solid state drive. Please note that working off of disk files can be quite slow on some computers, causing builds to take several days if not weeks.</p></li>
</ol>
<h1 id="classification"><a href="#classification">Classification</a></h1>
<p>To classify a set of sequences (reads), use the <code>kraken</code> command:</p>
<pre><code>kraken --db $DBNAME seqs.fa</code></pre>
<p>Output will be sent to standard output by default. The files containing the sequences to be classified should be specified on the command line. Sequences can also be provided through standard input using the special filename <code>/dev/fd/0</code>.</p>
<p>Note that to obtain optimum speeds, Kraken's database should be loaded into RAM first. This can be done through use of a ramdisk, if you have superuser permissions. Failing that, you can use the <code>--preload</code> switch to <code>kraken</code>, e.g.:</p>
<pre><code>kraken --preload --db $DBNAME seqs.fa</code></pre>
<p>The database files will be loaded before classification using this switch. See <a href="#memory-usage-and-efficiency">Memory Usage and Efficiency</a> for more information.</p>
<p>The <code>kraken</code> program allows several different options:</p>
<ul>
<li><p><strong>Multithreading</strong>: Use the <code>--threads NUM</code> switch to use multiple threads.</p></li>
<li><p><strong>Quick operation</strong>: Rather than searching all <span class="math"><em>k</em></span>-mers in a sequence, stop classification after the first database hit; use <code>--quick</code> to enable this mode. Note that <code>--min-hits</code> will allow you to require multiple hits before declaring a sequence classified, which can be especially useful with custom databases when testing to see if sequences either do or do not belong to a particular genome.</p></li>
<li><p><strong>Sequence filtering</strong>: Classified or unclassified sequences can be sent to a file for later processing, using the <code>--classified-out</code> and <code>--unclassified-out</code> switches, respectively.</p></li>
<li><p><strong>Output redirection</strong>: Output can be directed using standard shell redirection (<code>|</code> or <code>&gt;</code>), or using the <code>--output</code> switch.</p></li>
<li><p><strong>FASTQ input</strong>: Input is normally expected to be in FASTA format, but you can classify FASTQ data using the <code>--fastq-input</code> switch.</p></li>
<li><p><strong>Compressed input</strong>: Kraken can handle gzip and bzip2 compressed files as input by specifying the proper switch of <code>--gzip-compressed</code> or <code>--bzip2-compressed</code>.</p></li>
<li><p><strong>Input format auto-detection</strong>: If regular files are specified on the command line as input, Kraken will attempt to determine the format of your input prior to classification. You can disable this by explicitly specifying <code>--fasta-input</code>, <code>--fastq-input</code>, <code>--gzip-compressed</code>, and/or <code>--bzip2-compressed</code> as appropriate. Note that use of the character device file <code>/dev/fd/0</code> to read from standard input (aka <code>stdin</code>) will <strong>not</strong> allow auto-detection.</p></li>
<li><p><strong>Paired reads</strong>: Kraken does not query <span class="math"><em>k</em></span>-mers containing ambiguous nucleotides (non-ACGT). If you have paired reads, you can use this fact to your advantage and increase Kraken's accuracy by concatenating the pairs together with a single <code>N</code> between the sequences. Using the <code>--paired</code> option when running <code>kraken</code> will automatically do this for you; simply specify the two mate pair files on the command line. We have found this to raise sensitivity by about 3 percentage points over classifying the sequences as single-end reads.</p></li>
</ul>
<p>To get a full list of options, use <code>kraken --help</code>.</p>
<h1 id="output-format"><a href="#output-format">Output Format</a></h1>
<p>Each sequence classified by Kraken results in a single line of output. Output lines contain five tab-delimited fields; from left to right, they are:</p>
<ol style="list-style-type: decimal">
<li>&quot;C&quot;/&quot;U&quot;: one letter code indicating that the sequence was either classified or unclassified.</li>
<li>The sequence ID, obtained from the FASTA/FASTQ header.</li>
<li>The taxonomy ID Kraken used to label the sequence; this is 0 if the sequence is unclassified.</li>
<li>The length of the sequence in bp.</li>
<li>A space-delimited list indicating the LCA mapping of each <span class="math"><em>k</em></span>-mer in the sequence. For example, &quot;562:13 561:4 A:31 0:1 562:3&quot; would indicate that:
<ul>
<li>the first 13 <span class="math"><em>k</em></span>-mers mapped to taxonomy ID #562</li>
<li>the next 4 <span class="math"><em>k</em></span>-mers mapped to taxonomy ID #561</li>
<li>the next 31 <span class="math"><em>k</em></span>-mers contained an ambiguous nucleotide</li>
<li>the next <span class="math"><em>k</em></span>-mer was not in the database</li>
<li>the last 3 <span class="math"><em>k</em></span>-mers mapped to taxonomy ID #562</li>
</ul></li>
</ol>
<p>For users who want the full taxonomic name associated with each input sequence, we provide a script named <code>kraken-translate</code> that produces two different output formats for classified sequences. The script operates on the output of <code>kraken</code>, like so:</p>
<pre><code>kraken --db $DBNAME sequences.fa &gt; sequences.kraken
kraken-translate --db $DBNAME sequences.kraken &gt; sequences.labels</code></pre>
<p>(The same database used to run <code>kraken</code> should be used to translate the output; see <a href="#kraken-environment-variables">Kraken Environment Variables</a> below for ways to reduce redundancy on the command line.)</p>
<p>The file <code>sequences.labels</code> generated by the above example is a text file with two tab-delimited columns, and one line for each classified sequence in <code>sequences.fa</code>; unclassified sequences are not reported by <code>kraken-translate</code>. The first column of <code>kraken-translate</code>'s output are the sequence IDs of the classified sequences, and the second column contains the taxonomy of the sequence. For example, an output line from <code>kraken</code> of:</p>
<pre><code>C     SEQ1    562     36      562:6</code></pre>
<p>Would result in a corresponding output line from <code>kraken-translate</code> of:</p>
<pre><code>SEQ1  root;cellular organisms;Bacteria;Proteobacteria;Gammaproteobacteria;Enterobacteriales;Enterobacteriaceae;Escherichia;Escherichia coli</code></pre>
<p>Alternatively, <code>kraken-translate</code> accepts the option <code>--mpa-format</code> which will report only levels of the taxonomy with standard rank assignments (superkingdom, kingdom, phylum, class, order, family, genus, species), and uses pipes to delimit the various levels of the taxonomy. For example, <code>kraken-translate --mpa-format --db $DBNAME</code> with the above example output from <code>kraken</code> would result in the following line of output:</p>
<pre><code>SEQ1  d__Bacteria|p__Proteobacteria|c__Gammaproteobacteria|o__Enterobacteriales|f__Enterobacteriaceae|g__Escherichia|s__Escherichia_coli</code></pre>
<p>Taxonomy assignments above the superkingdom (<code>d__</code>) rank are represented as just &quot;root&quot; when using the <code>--mpa-report</code> option with <code>kraken-translate</code>.</p>
<h1 id="custom-databases"><a href="#custom-databases">Custom Databases</a></h1>
<p>We realize the standard database may not suit everyone's needs. Kraken also allows creation of customized databases.</p>
<p>To build a custom database:</p>
<ol style="list-style-type: decimal">
<li><p>Install a taxonomy. Usually, you will just use the NCBI taxonomy, which you can easily download using:</p>
<pre><code>kraken-build --download-taxonomy --db $DBNAME</code></pre>
<p>This will download the GI number to taxon map, as well as the taxonomic name and tree information from NCBI. These files can be found in <code>$DBNAME/taxonomy/</code> . If you need to modify the taxonomy, edits can be made to the <code>names.dmp</code> and <code>nodes.dmp</code> files in this directory; the <code>gi_taxid_nucl.dmp</code> file will also need to be updated appropriately.</p></li>
<li><p>Install a genomic library. Four sets of standard genomes are made easily available through <code>kraken-build</code>:</p>
<ul>
<li>bacteria: RefSeq complete bacterial/archaeal genomes</li>
<li>plasmids: RefSeq plasmid sequences</li>
<li>viruses: RefSeq complete viral genomes</li>
<li>human: GRCh38 human genome</li>
<li>mouse: GRCm38 mouse genome</li>
</ul>
<p>To download and install any one of these, use the <code>--download-library</code> switch, e.g.:</p>
<pre><code>kraken-build --download-library bacteria --db $DBNAME</code></pre>
Other genomes can also be added, but such genomes must meet certain requirements:
<ul>
<li>Sequences must be in a FASTA file (multi-FASTA is allowed)</li>
<li>Each sequence's ID (the string between the <code>&gt;</code> and the first whitespace character on the header line) must contain either a GI number to allow Kraken to lookup the correct taxa, or an explicit assignment of the taxonomy ID using <code>kraken:taxid</code> (see below).</li>
</ul>
<p>Replicons not downloaded from NCBI may need their taxonomy information assigned explicitly. This can be done using the string <code>kraken:taxid|XXX</code> in the sequence ID, with <code>XXX</code> replaced by the desired taxon ID. For example, to put a known adapter sequence in taxon 32630 (&quot;synthetic construct&quot;), you could use the following:</p>
<pre><code>&gt;sequence16|kraken:taxid|32630  Adapter sequence
CAAGCAGAAGACGGCATACGAGATCTTCGAGTGACTGGAGTTCCTTGGCACCCGAGAATTCCA</code></pre>
<p>The <code>kraken:taxid</code> string must begin the sequence ID or be immediately preceded by a pipe character (<code>|</code>). Explicit assignment of taxonomy IDs in this manner will override the GI number mapping provided by NCBI.</p>
<p>If your genomes meet the requirements above, then you can add each replicon to your database's genomic library using the <code>--add-to-library</code> switch, e.g.:</p>
<pre><code>kraken-build --add-to-library chr1.fa --db $DBNAME
kraken-build --add-to-library chr2.fa --db $DBNAME</code></pre>
<p>Note that if you have a list of files to add, you can do something like this in <code>bash</code>:</p>
<pre><code>for file in chr*.fa
do
    kraken-build --add-to-library $file --db $DBNAME
done</code></pre>
<p>Or even add all <code>*.fa</code> files found in the directory <code>genomes</code>:</p>
<pre><code>find genomes/ -name &#39;*.fa&#39; -print0 | \
    xargs -0 -I{} -n1 kraken-build --add-to-library {} --db $DBNAME</code></pre>
<p>(You may also find the <code>-P</code> option to <code>xargs</code> useful to add many files in parallel if you have multiple processors.)</p></li>
<li><p>Once your library is finalized, you need to build the database. Depending on your size requirements, you may want to adjust the <span class="math"><em>k</em></span>-mer and/or minimizer lengths from the defaults. Except for some small bookkeeping fields, a Kraken database will use <span class="math"><em>s</em><em>D</em></span> + <span class="math">8(4<sup><em>M</em></sup>)</span> bytes, where <span class="math"><em>s</em></span> is the number of bytes used to store the <span class="math"><em>k</em></span>-mer/taxon pair (usually 12, but lower for smaller <span class="math"><em>k</em></span>-mers), <span class="math"><em>D</em></span> is the number of distinct <span class="math"><em>k</em></span>-mers in your library and <span class="math"><em>M</em></span> is the length (in bp) of the minimizers. Although <span class="math"><em>D</em></span> does increase as <span class="math"><em>k</em></span> increases, it is impossible to know exactly how many distinct <span class="math"><em>k</em></span>-mers will exist in a library for a given <span class="math"><em>k</em></span> without actually performing the count. By default, <span class="math"><em>k</em></span> = 31 and <span class="math"><em>M</em></span> = 15.</p>
<p>The minimizers serve to keep <span class="math"><em>k</em></span>-mers that are adjacent in query sequences close to each other in the database, which allows Kraken to exploit the CPU cache. Changing the value of <span class="math"><em>M</em></span> can significantly affect the speed of Kraken, and neither increasing or decreasing <span class="math"><em>M</em></span> will guarantee faster or slower speed.</p>
<p>To build the database, you'll use the <code>--build</code> switch:</p>
<pre><code>kraken-build --build --db $DBNAME</code></pre>
<p>As noted above, you may want to also use any of <code>--threads</code>, <code>--kmer-len</code>, or <code>--minimizer-len</code> to adjust the database build time and/or final size.</p></li>
<li><p>Shrinking the database: The &quot;--shrink&quot; task allows you to take an existing Kraken database and create a smaller MiniKraken database from it. The use of this option removes all but a specified number of <span class="math"><em>k</em></span>-mer/taxon pairs to create a new, smaller database. For example:</p>
<pre><code>kraken-build --shrink 10000 --db $DBNAME --new-db minikraken</code></pre>
<p>This will create a new database named <code>minikraken</code> that contains 10000 <span class="math"><em>k</em></span>-mers selected from across the original database (<code>$DBNAME</code>).</p>
<p>The <code>--shrink</code> task is only meant to be run on a completed database. However, if you know before you create a database that you will only be able to use a certain amount of memory, you can use the <code>--max-db-size</code> switch for the <code>--build</code> task to provide a maximum size (in GB) for the database. This allows you to create a MiniKraken database without having to create a full Kraken database first.</p></li>
</ol>
<p>A full list of options for <code>kraken-build</code> can be obtained using <code>kraken-build --help</code>.</p>
<p>After building a database, if you want to reduce the disk usage of the database you can use <code>kraken-build</code>'s <code>--clean</code> switch to remove all intermediate files from the database directory.</p>
<h1 id="memory-usage-and-efficiency"><a href="#memory-usage-and-efficiency">Memory Usage and Efficiency</a></h1>
<p>Kraken's execution requires many random accesses to a very large file. To obtain maximal speed, these accesses need to be made as quickly as possible. This means that the database must be in physical memory during execution. Although we provide the <code>--preload</code> option to Kraken for users who cannot use a ramdisk, the ramdisk is likely the simplest option, and is well-suited for installations on computers where Kraken is to be run a majority of the time. In addition, using a ramdisk allows the initial start-up of Kraken to be accomplished much more quickly. If a ramdisk is used, the <code>--preload</code> switch should not be used.</p>
<p>We also note that in some cases, <code>--preload</code> may not be needed (or even advisable). If you know that your database is already in memory (for example, if it has been recently read or unzipped, then it should be in your operating system cache, which resides in physical memory), then there is no need to perform this step. We have noticed that in low-memory (~8 GB) situations, preloading a MiniKraken DB is actually much slower than simply using <code>cat minikraken/database.* &gt; /dev/null</code>. The selection of the best way to get the database into memory is dependent on several factors, including your total amount of RAM, operating system, and current free memory. For this reason, you may need to experiment with your own setup to find a good solution for you.</p>
<p>To create a ramdisk, you will need to have superuser (root) permission. As root, you can use the following commands to create a ramdisk:</p>
<pre><code>mkdir /ramdisk
mount -t ramfs none /ramdisk</code></pre>
<p>Optionally, you may have a trusted user who you want to be able to copy databases into this directory. In that case, you'll need to make that user the owner of the directory via chown.</p>
<p>To put the database on the ramdisk, simply copy the database directory to the ramdisk directory:</p>
<pre><code>cp -a $DBNAME /ramdisk</code></pre>
<p>And then you can use it with Kraken by specifying the database copy on the ramdisk, e.g.:</p>
<pre><code>kraken --db /ramdisk/$DBNAME seqs.fa</code></pre>
<p>Note that anything copied into a ramdisk will be deleted if the ramdisk is unmounted or the computer is restarted, so make sure that you have a copy of the database on a hard disk (or other non-volatile storage).</p>
<p>Note that when using the <code>--paired</code> option, Kraken will not (by default) make any attempt to ensure that the two files you specify are indeed matching sets of paired-end reads. To verify that the names of each read do indeed match, you can use the <code>--check-names</code> option in combination with the <code>--paired</code> option.</p>
<h1 id="sample-reports"><a href="#sample-reports">Sample Reports</a></h1>
<p>To get an idea as to Kraken's results across an entire sample, we provide the <code>kraken-report</code> script. It is used like this:</p>
<pre><code>kraken-report --db $DBNAME kraken.output</code></pre>
<p>Note that the database used must be the same as the one used to generate the output file, or the report script may encounter problems. Output is sent to standard output.</p>
<p>The output of <code>kraken-report</code> is tab-delimited, with one line per taxon. The fields of the output, from left-to-right, are as follows:</p>
<ol style="list-style-type: decimal">
<li>Percentage of reads covered by the clade rooted at this taxon</li>
<li>Number of reads covered by the clade rooted at this taxon</li>
<li>Number of reads assigned directly to this taxon</li>
<li>A rank code, indicating (U)nclassified, (D)omain, (K)ingdom, (P)hylum, (C)lass, (O)rder, (F)amily, (G)enus, or (S)pecies. All other ranks are simply '-'.</li>
<li>NCBI taxonomy ID</li>
<li>indented scientific name</li>
</ol>
<p>The scientific names are indented using spaces, according to the tree structure specified by the taxonomy.</p>
<p>By default, taxa with no reads assigned to (or under) them will not have any output produced. However, if you wish to have all taxa displayed, you can use the <code>--show-zeros</code> switch to do so. This can be useful if you are looking to do further downstream analysis of the reports, and want to compare samples. Sorting by the taxonomy ID (using <code>sort -nf5</code>) can provide a consistent line ordering between reports.</p>
<p>In addition, we also provide the program <code>kraken-mpa-report</code>; this program provides output in a format similar to MetaPhlAn's tab-delimited output. For <code>kraken-mpa-report</code>, multiple Kraken output files can be specified on the command line and each will be treated as a separate sample. For each taxon at the standard ranks (from domain to species), the count of reads in each sample assigned to any node in the clade rooted at that taxon is displayed. <code>kraken-mpa-report</code> is run in the same manner as <code>kraken-report</code>, and its output is also sent to standard output.</p>
<h1 id="confidence-scoring"><a href="#confidence-scoring">Confidence Scoring</a></h1>
<p>At present, we have not yet developed a confidence score with a solid probabilistic interpretation for Kraken. However, we have developed a simple scoring scheme that has yielded good results for us, and we've made that available in the <code>kraken-filter</code> script. The approach we use allows a user to specify a threshold score in the [0,1] interval; the <code>kraken-filter</code> script then will adjust labels up the tree until the label's score (described below) meets or exceeds that threshold. If a label at the root of the taxonomic tree would not have a score exceeding the threshold, the sequence is called unclassified by kraken-filter.</p>
<p>A sequence label's score is a fraction <span class="math"><em>C</em></span>/<span class="math"><em>Q</em></span>, where <span class="math"><em>C</em></span> is the number of <span class="math"><em>k</em></span>-mers mapped to LCA values in the clade rooted at the label, and <span class="math"><em>Q</em></span> is the number of <span class="math"><em>k</em></span>-mers in the sequence that lack an ambiguous nucleotide (i.e., they were queried against the database). Consider the example of the LCA mappings in Kraken's output given earlier:</p>
<p>&quot;562:13 561:4 A:31 0:1 562:3&quot; would indicate that:</p>
<ul>
<li>the first 13 <span class="math"><em>k</em></span>-mers mapped to taxonomy ID #562</li>
<li>the next 4 <span class="math"><em>k</em></span>-mers mapped to taxonomy ID #561</li>
<li>the next 31 <span class="math"><em>k</em></span>-mers contained an ambiguous nucleotide</li>
<li>the next <span class="math"><em>k</em></span>-mer was not in the database</li>
<li>the last 3 <span class="math"><em>k</em></span>-mers mapped to taxonomy ID #562</li>
</ul>
<p>In this case, ID #561 is the parent node of #562. Here, a label of #562 for this sequence would have a score of <span class="math"><em>C</em></span>/<span class="math"><em>Q</em></span> = (13+3)/(13+4+1+3) = 16/21. A label of #561 would have a score of <span class="math"><em>C</em></span>/<span class="math"><em>Q</em></span> = (13+4+3)/(13+4+1+3) = 20/21. If a user specified a threshold over 16/21, kraken-filter would adjust the original label from #562 to #561; if the threshold was greater than 20/21, the sequence would become unclassified.</p>
<p><code>kraken-filter</code> is used like this:</p>
<pre><code>kraken-filter --db $DBNAME [--threshold NUM] kraken.output</code></pre>
<p>If not specified, the threshold will be 0. <code>kraken-filter</code>'s output is similar to <code>kraken</code>'s, but a new field between the length and LCA mapping list is present, indicating the new label's score (or the root label's score if the sequence has become unclassified).</p>
<p>To give some guidance toward selecting an appropriate threshold, we show here the results of different thresholds on the MiSeq metagenome from the <a href="http://genomebiology.com/2014/15/3/R46">Kraken paper</a> (see the paper for more details; note that the database used here is more recent than that used in the paper). Precision, sensitivity, and F-score are measured at the genus rank:</p>
<div id="confidence-score-table">
<table>
<thead>
<tr class="header">
<th align="left">Thres</th>
<th align="left">Prec</th>
<th align="left">Sens</th>
<th align="left">F-score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">95.43</td>
<td align="left">77.32</td>
<td align="left">85.43</td>
</tr>
<tr class="even">
<td align="left">0.05</td>
<td align="left">97.28</td>
<td align="left">76.31</td>
<td align="left">85.53</td>
</tr>
<tr class="odd">
<td align="left">0.10</td>
<td align="left">98.25</td>
<td align="left">75.13</td>
<td align="left">85.15</td>
</tr>
<tr class="even">
<td align="left">0.15</td>
<td align="left">98.81</td>
<td align="left">73.87</td>
<td align="left">84.54</td>
</tr>
<tr class="odd">
<td align="left">0.20</td>
<td align="left">99.13</td>
<td align="left">72.82</td>
<td align="left">83.96</td>
</tr>
<tr class="even">
<td align="left">0.25</td>
<td align="left">99.38</td>
<td align="left">71.74</td>
<td align="left">83.33</td>
</tr>
<tr class="odd">
<td align="left">0.30</td>
<td align="left">99.55</td>
<td align="left">70.75</td>
<td align="left">82.71</td>
</tr>
<tr class="even">
<td align="left">0.35</td>
<td align="left">99.61</td>
<td align="left">69.53</td>
<td align="left">81.90</td>
</tr>
<tr class="odd">
<td align="left">0.40</td>
<td align="left">99.66</td>
<td align="left">68.35</td>
<td align="left">81.09</td>
</tr>
<tr class="even">
<td align="left">0.45</td>
<td align="left">99.70</td>
<td align="left">66.93</td>
<td align="left">80.09</td>
</tr>
<tr class="odd">
<td align="left">0.50</td>
<td align="left">99.71</td>
<td align="left">65.49</td>
<td align="left">79.06</td>
</tr>
</tbody>
</table>
</div>
<p>As can be seen, with no threshold (i.e., Kraken's original labels), Kraken's precision is fairly high, but it does increase with the threshold. Diminishing returns apply, however, and there is a loss in sensitivity that must be taken into account when deciding on the threshold to use for your own project.</p>
<h1 id="kraken-environment-variables"><a href="#kraken-environment-variables">Kraken Environment Variables</a></h1>
<p>The Kraken programs (with the exception of <code>kraken-build</code>) support the use of some environment variables to help in reducing command line lengths:</p>
<ul>
<li><p><strong><code>KRAKEN_NUM_THREADS</code></strong>: this variable is only used by <code>kraken</code>; if the <code>--threads</code> option is not supplied to <code>kraken</code>, then the value of this variable (if it is set) will be used as the number of threads to run <code>kraken</code>.</p></li>
<li><p><strong><code>KRAKEN_DB_PATH</code></strong>: much like the <code>PATH</code> variable is used for executables by your shell, <code>KRAKEN_DB_PATH</code> is a colon-separated list of directories that will be searched for the database you name if the named database does not have a slash (<code>/</code>) character. By default, Kraken assumes the value of this variable is &quot;<code>.</code>&quot; (i.e., the current working directory). This variable can be used to create one (or more) central repositories of Kraken databases in a multi-user system. Example usage in bash:</p>
<pre><code>export KRAKEN_DB_PATH=&quot;/home/user/my_kraken_dbs:/data/kraken_dbs:&quot;</code></pre>
<p>This will cause three directories to be searched, in this order:</p>
<ol style="list-style-type: decimal">
<li><code>/home/user/my_kraken_dbs</code></li>
<li><code>/data/kraken_dbs</code></li>
<li>the current working directory (caused by the empty string as the third colon-separated field in the <code>KRAKEN_DB_PATH</code> string)</li>
</ol>
<p>The search for a database will stop when a name match is found; if two directories in the <code>KRAKEN_DB_PATH</code> have databases with the same name, the directory of the two that is searched first will have its database selected.</p>
<p>If the above variable and value are used, and the databases <code>/data/kraken_dbs/mainDB</code> and <code>./mainDB</code> are present, then</p>
<pre><code>kraken --db mainDB sequences.fa</code></pre>
<p>will classify <code>sequences.fa</code> using <code>/data/kraken_dbs/mainDB</code>; if instead you wanted to use the <code>mainDB</code> present in the current directory, you would need to specify a directory path to that database in order to circumvent searching, e.g.:</p>
<pre><code>kraken --db ./mainDB sequences.fa</code></pre>
<p>Note that the <code>KRAKEN_DB_PATH</code> directory list can be skipped by the use of any absolute (beginning with <code>/</code>) or relative pathname (including at least one <code>/</code>) as the database name.</p></li>
<li><p><strong><code>KRAKEN_DEFAULT_DB</code></strong>: if no database is supplied with the <code>--db</code> option, the database named in this variable will be used instead. Using this variable, you can avoid using <code>--db</code> if you only have a single database that you usually use, e.g. in bash:</p>
<pre><code>export KRAKEN_DEFAULT_DB=&quot;/home/user/krakendb&quot;
kraken sequences.fa | kraken-report &gt; sequences.kreport</code></pre>
<p>This will classify <code>sequences.fa</code> using the <code>/home/user/krakendb</code> directory.</p>
<p>Note that the value of <code>KRAKEN_DEFAULT_DB</code> will also be interpreted in the context of the value of <code>KRAKEN_DB_PATH</code> if you don't set <code>KRAKEN_DEFAULT_DB</code> to an absolute or relative pathname. Given the earlier example in this section, the following:</p>
<pre><code>export KRAKEN_DEFAULT_DB=&quot;mainDB&quot;
kraken sequences.fa</code></pre>
<p>will use <code>/data/kraken_dbs/mainDB</code> to classify <code>sequences.fa</code>.</p></li>
</ul>
<h1 id="upgrading-databases-to-v0.10"><a href="#upgrading-databases-to-v0.10">Upgrading Databases to v0.10+</a></h1>
<p>The minimizer ordering in Kraken versions prior to v0.10.0-beta was a simple lexicographical ordering that provided a suboptimal distribution of k-mers within the bins. Ideally, the bin sizes would be uniform, but simple lexicographical ordering creates a bias toward low-complexity minimizers. To resolve this, the ordering is now &quot;scrambled&quot; by XORing all minimizers with a predefined constant to toggle half of each minimizer's bits before sorting. The more evenly distributed bins provide better caching performance, but databases created in this way are not compatible with earlier versions of Kraken. Kraken versions from v0.10.0-beta up to (but not including) v1.0 will support the use of the older databases, but we nonetheless recommend one of the two following options:</p>
<ol style="list-style-type: decimal">
<li><p>Build a new database. This is the preferred option, as a newly-created database will have the latest genomes and NCBI taxonomy information.</p></li>
<li><p>Re-sort an existing database. If you have a custom database, you may want to simply reformat the database to provide you with Kraken's increased speed. To do so, you'll need to do the following:</p>
<pre><code>kraken-build --upgrade --db $DBNAME</code></pre>
<p>(<strong>Note</strong>: the <code>--threads</code> switch is both valid and encouraged with this operation.)</p>
<p>This command will <strong>not</strong> delete your existing <code>$DBNAME/database.*</code> files, but will simply rename them. If you're satisfied with the new database's performance, then you can use <code>kraken-build</code>'s <code>--clean</code> option to remove the old files and save space.</p>
<p>Sorting the database is step 3 of the build process, so you should expect a database upgrade to take about as long as step 3 took when building the original database.</p></li>
</ol>
<p>Note that the rest of Kraken v0.10.0-beta's speed improvements are available without upgrading or changing your database.</p>
</body>
</html>
